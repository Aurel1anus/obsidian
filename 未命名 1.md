$utilization=\frac{total-request}{total}$

## 关于如何找到所有安全序列：
以下是一种可能的实现过程：

1.  创建一个空的安全序列列表和一个已访问序列的集合。
2.  从所有未访问的进程中选择一个可以满足需要的进程，将其添加到当前安全序列中。
3.  为当前安全序列中的进程释放资源，更新可用资源。
4.  重复步骤 2 和 3 直到所有进程都添加到了安全序列中。
5.  回溯到最近的分支点，选择下一个可行的进程并继续搜索，直到所有安全序列都被找到。

函数 dfs() 是一个递归函数，它接受当前安全序列、Banker 对象、已访问的进程集合、以及一个安全序列列表作为参数。如果当前安全序列中包含所有进程，则将其添加到安全序列列表中并返回。否则，遍历所有未访问的进程，并选择可以满足需要的进程。如果选择的进程可以安全分配资源，则将其添加到安全序列中并递归调用 dfs() 函数。如果递归调用返回后，则释放该进程分配的资源并从当前安全序列中删除该进程。如果遍历所有进程后仍然没有找到安全序列，则回溯到最近的分支点。

## 关于如何将安全序列按资源利用率进行排序
要对银行家算法的所有安全序列做资源利用率的排序，需要先计算每个安全序列的资源利用率。资源利用率可以通过计算进程已分配的资源与总资源量的比例来获得。然后，可以将所有安全序列按照资源利用率从高到低排序。

下面是一个可能的实现过程：

1.  对于每个安全序列，计算其资源利用率。
2.  使用 Python 的 zip() 函数将每个安全序列和其资源利用率打包为一个元组。
3.  使用 sorted() 函数根据资源利用率对元组列表进行排序，可以指定 reverse=True 参数以进行降序排序。
4.  将排序后的元组列表解压缩，并仅保留安全序列。